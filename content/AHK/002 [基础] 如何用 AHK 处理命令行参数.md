Title: [基础] 如何用 AHK 处理命令行参数
Date: 2016.04.26 08:17
Category: AHK

写过 C 语言的朋友都清楚 main() 函数可以有两个参数，argc 和 argv，argc 是命令行参数个数，argv 则用于访问具体参数，使用起来非常容易。那么用 AHK 如何访问命令行参数呢？

官方文档有介绍，但并不是很详细，容易让人看后感觉一头雾水，这里简单整理一下。

## 获取参数的个数

要处理参数，得先清楚有没有参数，也就是获取参数的个数。

%0% 内部变量是用来存放参数个数的，这样可以用 MsgBox 弹出参数个数，是不是很简单？

```
MsgBox, %0%
```

但需要注意的时，如果一个变量名是 a，我们可以用 MsgBox, %a% 和 MsgBox, % a 两种方式在 MsgBox 中访问 a。但此时我们不能用 MsgBox, % 0 来访问参数个数，因为这样会直接弹出数字 0。那么如果我一定要在 MsgBox 的参数前加 % 呢？可以先将 %0% 转存到其他变量：

```
; 注意这里不能用 :=
argc = %0%
MsgBox, % argc
```

这样 argc 就和其他变量无异了。

如果我们想判断命令行参数有多少个，也有两种方式：

第一种方式，也是官方文档中的例子：

```
if 0 = 2
{
    MsgBox, 有两个参数
}
```

有些朋友看到这就一头雾水了，0 怎么会等于 2？其实这句 if 判断里，2 确实是数字 2，而 0 并非数字 0，而是 %0% 的值，也就是命令行参数的个数。从这里也可以看出 AHK 语言不严谨的地方。如果实在认为这样判断太违背直觉，无法接受，也可以使用迂回的办法。

第二种方式：

```
argc = %0%

if (argc == 2)
{
    MsgBox, 有两个参数
}
```

这样就正常多了。但需要注意，如下用法是错误的：

```
if (%0% == 2)
{
    MsgBox, 有两个参数
}
```

这也是让很多人困惑的地方。毕竟 %0% 是特例，不能像用其他正常变量一样使用，需要特殊记忆一下。

## 获取具体参数

当我们知道了参数个数，就可以去读参数的值了，有了刚才的铺垫，这一步也容易很多了。

%1% 是第一个参数，%2% 是第二个参数，依次类推。而访问 %1% %2% 的方式，和访问 %0% 是一样的。为了不违反直觉，还是建议先将参数转存到一个有意义的变量名，再作处理，例如：

```
flag = %1%

if (flag == "-c")
{
    MsgBox, -c 参数已传入
}
```

## 遍历所有参数

遍历所有参数是一种常见的处理方法，在 AHK 里也是比较容易的：

```
Loop, %0%
{
    param := %A_Index%
    MsgBox, %param%
}
```

这里又有事情需要注意了。这个 Loop 看起来没什么，%0% 就是参数的个数，有几个参数就循环几次，但`param := %A_Index%`，这里用的是`:=`，而不是`=`。这个之前的`param = %1%`是不同的。为什么有这样的区别呢？

A_Index 存放的是一个数字，如果直接用`param := A_Index`，那么 param 的值自然也就是数字了，而不是对应的参数。所以需要用`%`将这个数字解析成参数。这个用法又和通常的变量有所不同。

这种用法并非处理命令行参数时的特例，我们可以看下这个例子：

```
a := "b"
b := "c"
d := %a%
MsgBox, %d%
```

a 的值是 b，b 的值是 c，`d := %a%`中，%a% 的值是 b，所以这里的`d := %a%`等同于`d := b`，于是 d 的值是 c。也就是可以将变量的值解析成变量名，再去取变量的值，这样的技巧在很多语言里都可以用。
